import { isArray, isFunction, isObject, isString } from "../utils";

export const format: any = {
	number(value: any) {
		return isArray(value) ? value.map(Number) : Number(value);
	},
	string(value: any) {
		return isArray(value) ? value.map(String) : String(value);
	},
	split(value: string) {
		if (isString(value)) {
			return value.split(",").filter(Boolean);
		} else if (isArray(value)) {
			return value;
		} else {
			return [];
		}
	},
	join(value: any[]) {
		return isArray(value) ? value.join(",") : value;
	},
	boolean(value: any) {
		return Boolean(value);
	},
	booleanNumber(value: any) {
		return value ? 1 : 0;
	},
	datetimeRange(value: any[], { form, method, prop }: any) {
		const key = prop.charAt(0).toUpperCase() + prop.slice(1);

		const start = `start${key}`;
		const end = `end${key}`;

		if (method == "bind") {
			return [form[start], form[end]];
		} else {
			const [startTime, endTime] = value || [];
			form[start] = startTime;
			form[end] = endTime;
			return undefined;
		}
	},
	splitJoin(value: any, { method }: any) {
		if (method == "bind") {
			return isString(value) ? value.split(",").filter(Boolean) : value;
		} else {
			return isArray(value) ? value.join(",") : value;
		}
	}
};

function parse(method: string, { value, hook: pipe, form, prop }: any) {
	if (!pipe) {
		return value;
	}

	let pipes = [];

	if (isString(pipe)) {
		if (format[pipe]) {
			pipes = [pipe];
		} else {
			console.error(`${pipe} is not found.`);
			return value;
		}
	} else if (isArray(pipe)) {
		pipes = pipe;
	} else if (isObject(pipe)) {
		pipes = isArray(pipe[method]) ? pipe[method] : [pipe[method]];
	} else if (isFunction(pipe)) {
		pipes = [pipe];
	} else {
		console.error(`Hook data error!`);
		return value;
	}

	let v = value;

	pipes.forEach((e: any) => {
		let f = null;

		if (isString(e)) {
			f = format[e];
		} else if (isFunction(e)) {
			f = e;
		}

		if (f) {
			v = f(v, {
				method,
				form,
				prop
			});
		}
	});

	return v;
}

export default {
	bind(data: any) {
		return parse("bind", data);
	},

	submit(data: any) {
		return parse("submit", data);
	}
};
