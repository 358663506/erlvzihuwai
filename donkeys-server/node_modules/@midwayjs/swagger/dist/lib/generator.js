"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwaggerMetaGenerator = void 0;
const decorator_1 = require("@midwayjs/decorator");
const document_1 = require("./document");
const createAPI_1 = require("./createAPI");
class SwaggerMetaGenerator {
    constructor(options) {
        var _a;
        this.document = new document_1.SwaggerDocument();
        const info = new document_1.SwaggerDocumentInfo();
        info.title = (options === null || options === void 0 ? void 0 : options.title) || 'Midway2 Swagger API';
        info.version = options.version || '1.0.0';
        info.description = options === null || options === void 0 ? void 0 : options.description;
        info.termsOfService = options === null || options === void 0 ? void 0 : options.termsOfService;
        info.contact = options === null || options === void 0 ? void 0 : options.contact;
        info.license = ((_a = options === null || options === void 0 ? void 0 : options.license) === null || _a === void 0 ? void 0 : _a.name) ? options === null || options === void 0 ? void 0 : options.license : undefined;
        this.document.info = info;
    }
    generateController(module) {
        const controllerOption = (0, decorator_1.getClassMetadata)(decorator_1.CONTROLLER_KEY, module);
        const prefix = controllerOption.prefix;
        const tag = new document_1.SwaggerDocumentTag();
        if (prefix !== '/') {
            tag.name =
                (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.tagName) ||
                    (/^\//.test(prefix) ? prefix.split('/')[1] : prefix);
            tag.description = (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.description) || tag.name;
        }
        else {
            tag.name = (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.tagName) || 'default';
            tag.description = (controllerOption === null || controllerOption === void 0 ? void 0 : controllerOption.routerOptions.description) || tag.name;
        }
        this.document.tags.push(tag);
        // const globalMiddleware = controllerOption.routerOptions.middleware;
        // get router info
        const webRouterInfo = (0, decorator_1.getClassMetadata)(decorator_1.WEB_ROUTER_KEY, module);
        if (webRouterInfo && typeof webRouterInfo[Symbol.iterator] === 'function') {
            for (const webRouter of webRouterInfo) {
                let url = (prefix + webRouter.path).replace('//', '/');
                url = replaceUrl(url, parseParamsInPath(url));
                const router = new document_1.SwaggerDocumentRouter(webRouter.requestMethod, url);
                router.tags = [tag.name];
                this.generateRouter(webRouter, router, module);
                this.document.addRouter(router);
            }
        }
    }
    generate() {
        return this.document.toJSON();
    }
    generateRouter(webRouterInfo, swaggerRouter, module) {
        const ins = new module();
        const swaggerApi = (0, decorator_1.getPropertyMetadata)(createAPI_1.SWAGGER_DOCUMENT_KEY, ins, webRouterInfo.method);
        swaggerRouter.summary =
            (swaggerApi === null || swaggerApi === void 0 ? void 0 : swaggerApi.summary) || webRouterInfo.summary || webRouterInfo.routerName;
        swaggerRouter.description =
            (swaggerApi === null || swaggerApi === void 0 ? void 0 : swaggerApi.description) ||
                webRouterInfo.description ||
                webRouterInfo.routerName;
        // swaggerRouter.operationId = webRouterInfo.method;
        swaggerRouter.parameters = [];
        const routeArgsInfo = (0, decorator_1.getPropertyDataFromClass)(decorator_1.WEB_ROUTER_PARAM_KEY, module, webRouterInfo.method) || [];
        // 获取方法参数类型
        const paramTypes = (0, decorator_1.getMethodParamTypes)(ins, webRouterInfo.method);
        for (const routeArgs of routeArgsInfo) {
            const swaggerParameter = new document_1.SwaggerDocumentParameter();
            const argsApiInfo = swaggerApi === null || swaggerApi === void 0 ? void 0 : swaggerApi.params[routeArgs.index];
            swaggerParameter.description = argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.description;
            swaggerParameter.name = (argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.name) || (routeArgs === null || routeArgs === void 0 ? void 0 : routeArgs.propertyData);
            swaggerParameter.in = convertTypeToString(routeArgs.type);
            swaggerParameter.required = argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.required;
            swaggerParameter.deprecated = argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.deprecated;
            swaggerParameter.allowEmptyValue = argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.allowEmptyValue;
            swaggerParameter.example = argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.example;
            if (swaggerParameter.in === 'path') {
                swaggerParameter.required = true;
                // if path not include this args, must be ignore
                if (swaggerRouter.url.indexOf('{' + swaggerParameter.name + '}') === -1) {
                    continue;
                }
            }
            if ((0, decorator_1.isClass)(paramTypes[routeArgs.index])) {
                this.generateSwaggerDefinition(paramTypes[routeArgs.index]);
                swaggerParameter.schema = {
                    $ref: '#/components/schemas/' + paramTypes[routeArgs.index].name,
                };
            }
            else {
                swaggerParameter.schema = {
                    type: convertSchemaType(paramTypes[routeArgs.index].name),
                    name: undefined,
                };
            }
            // add body
            if (swaggerParameter.in === 'body') {
                swaggerRouter.requestBody = {
                    description: (argsApiInfo === null || argsApiInfo === void 0 ? void 0 : argsApiInfo.description) || (routeArgs === null || routeArgs === void 0 ? void 0 : routeArgs.propertyData),
                    content: {
                        'application/json': {
                            schema: swaggerParameter.schema,
                        },
                    },
                };
                continue;
            }
            // add parameter
            swaggerRouter.parameters.push(swaggerParameter);
        }
        swaggerRouter.responses = {};
        for (const apiResponse of (swaggerApi === null || swaggerApi === void 0 ? void 0 : swaggerApi.response) || []) {
            // 获取方法返回值
            swaggerRouter.responses[apiResponse.status] = {
                description: apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.description,
                headers: apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.headers,
                content: apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.content,
            };
        }
        // 兜底加个 200
        if (Object.keys(swaggerRouter.responses).length === 0) {
            swaggerRouter.responses = { 200: { description: '' } };
        }
    }
    generateSwaggerDefinition(definitionClass) {
        var _a, _b;
        const swaggerDefinition = new document_1.SwaggerDefinition();
        swaggerDefinition.name = definitionClass.name;
        swaggerDefinition.type = 'object';
        const properties = (0, decorator_1.getClassMetadata)(createAPI_1.SWAGGER_DOCUMENT_KEY, definitionClass);
        for (const propertyName in properties) {
            swaggerDefinition.properties[propertyName] = {
                type: properties[propertyName].type.toLowerCase(),
                description: properties[propertyName].description,
                example: properties[propertyName].example,
            };
        }
        // for rule decorator
        const rules = (0, decorator_1.getClassExtendedMetadata)(decorator_1.RULES_KEY, definitionClass);
        if (rules) {
            const properties = Object.keys(rules);
            for (const property of properties) {
                // set required
                if (((_b = (_a = rules[property]) === null || _a === void 0 ? void 0 : _a._flags) === null || _b === void 0 ? void 0 : _b.presence) === 'required') {
                    swaggerDefinition.required.push(property);
                }
                // 没找到这行代码对应的装饰器
                // get property description
                let propertyInfo = (0, decorator_1.getPropertyMetadata)(createAPI_1.SWAGGER_DOCUMENT_KEY, definitionClass, property);
                if (!propertyInfo) {
                    propertyInfo = this.generateSwaggerByJoiProperty(rules[property], joinCamel(definitionClass.name, property));
                }
                if (swaggerDefinition.properties[property] && !(propertyInfo === null || propertyInfo === void 0 ? void 0 : propertyInfo.$ref)) {
                    mixWhenPropertyEmpty(swaggerDefinition.properties[property], propertyInfo);
                }
                else {
                    swaggerDefinition.properties[property] = propertyInfo;
                }
            }
        }
        this.document.definitions.push(swaggerDefinition);
        // DTO
        for (const key in properties) {
            // 必须加了属性装饰器
            if (!(rules === null || rules === void 0 ? void 0 : rules[key]) &&
                properties[key].originDesign &&
                !properties[key].isBaseType) {
                this.generateSwaggerDefinition(properties[key].originDesign);
                // 把复杂类型属性指向新的定义
                swaggerDefinition.properties[key] = {};
                swaggerDefinition.properties[key]['$ref'] =
                    '#/components/schemas/' + properties[key].type;
            }
        }
    }
    generateSwaggerByJoiProperty(joiSchema, pathName) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const describe = joiSchema.describe();
        if (((_a = describe.flags) === null || _a === void 0 ? void 0 : _a.presence) === 'forbidden') {
            return undefined;
        }
        let define = {
            type: describe.type,
            default: (_b = describe.flags) === null || _b === void 0 ? void 0 : _b.default,
            description: (_c = describe.flags) === null || _c === void 0 ? void 0 : _c.description,
            example: (_d = describe.examples) === null || _d === void 0 ? void 0 : _d.join(' '),
        };
        let min;
        let max;
        for (const r of describe.rules || []) {
            if (r.name === 'min' && r.args) {
                min = r.args.limit;
            }
            else if (r.name === 'max') {
                max = r.args.limit;
            }
        }
        if ((_e = describe.flags) === null || _e === void 0 ? void 0 : _e.only) {
            define.enum = describe.allow;
        }
        if (describe.invalid) {
            define.not = { enum: describe.invalid };
        }
        switch (describe.type) {
            case 'string':
                define.minLength = min;
                define.maxLength = max;
                break;
            case 'number':
                define.minimum = min;
                define.maximum = max;
                if ((_f = describe.rules) === null || _f === void 0 ? void 0 : _f.some(r => r.name === 'integer')) {
                    define.type = 'integer';
                }
                break;
            case 'date':
                define.type = 'string';
                define.format = 'date-time';
                break;
            case 'object': {
                const swaggerDefinition = new document_1.SwaggerDefinition();
                const schemaMeta = (_g = describe.metas) === null || _g === void 0 ? void 0 : _g.find(m => Boolean(m.id));
                swaggerDefinition.name = (schemaMeta === null || schemaMeta === void 0 ? void 0 : schemaMeta.id) || pathName;
                swaggerDefinition.type = 'object';
                swaggerDefinition.required = [];
                for (const prop of (_h = joiSchema.$_terms) === null || _h === void 0 ? void 0 : _h.keys) {
                    if (((_j = prop.schema._flags) === null || _j === void 0 ? void 0 : _j.presence) === 'required') {
                        swaggerDefinition.required.push(prop.key);
                    }
                    swaggerDefinition.properties[prop.key] =
                        this.generateSwaggerByJoiProperty(prop.schema, joinCamel(pathName, prop.key));
                }
                this.document.definitions.push(swaggerDefinition);
                define = { $ref: '#/components/schemas/' + swaggerDefinition.name };
                break;
            }
            case 'array':
                define.minItems = min;
                define.maxItems = max;
                if (joiSchema.$_terms.items[0]) {
                    define.items = this.generateSwaggerByJoiProperty(joiSchema.$_terms.items[0], pathName);
                }
        }
        return define;
    }
}
exports.SwaggerMetaGenerator = SwaggerMetaGenerator;
function joinCamel(word1, word2) {
    return `${word1}${word2[0].toUpperCase()}${word2.slice(1)}`;
}
function convertTypeToString(type) {
    switch (type) {
        case decorator_1.RouteParamTypes.HEADERS:
            return 'header';
        case decorator_1.RouteParamTypes.QUERY:
            return 'query';
        case decorator_1.RouteParamTypes.PARAM:
            return 'path';
        case decorator_1.RouteParamTypes.BODY:
            return 'body';
        default:
            return 'header';
    }
}
/**
 * 解释路由上的参数
 * @param url
 */
function parseParamsInPath(url) {
    const names = [];
    url.split('/').forEach(item => {
        if (item.startsWith(':')) {
            const paramName = item.substr(1);
            names.push(paramName);
        }
    });
    return names;
}
/**
 * 替换成 openapi 的url
 * @param url
 * @param names
 */
function replaceUrl(url, names) {
    names.forEach(n => {
        url = url.replace(`:${n}`, `{${n}}`);
    });
    return url;
}
function convertSchemaType(value) {
    switch (value) {
        case 'Object':
            return 'object';
        case 'Boolean':
            return 'boolean';
        case 'Number':
            return 'number';
        case 'String':
            return 'string';
        default:
            return 'object';
    }
}
function mixWhenPropertyEmpty(target, source) {
    for (const key in source) {
        if (!target[key] && source[key]) {
            target[key] = source[key];
        }
    }
}
//# sourceMappingURL=generator.js.map