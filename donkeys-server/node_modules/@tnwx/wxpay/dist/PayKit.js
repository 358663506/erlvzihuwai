"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const RequestMethod_1 = require("./RequestMethod");
const kits_1 = require("@tnwx/kits");
const urlencode = require("urlencode");
const os = require("os");
const util = require("util");
/**
 * @author Javen
 * @copyright javendev@126.com
 * @description 微信支付工具类
 */
class PayKit {
    /**
     * 验证签名
     * @param signature   待验证的签名
     * @param body        应答主体
     * @param nonce       随机串
     * @param timestamp   时间戳
     * @param publicKey   平台公钥
     */
    static verifySignature(signature, body, nonce, timestamp, publicKey) {
        let buildSignMessage = this.buildRepSignMessage(timestamp, nonce, body);
        return kits_1.Kits.sha256WithRsaVerify(publicKey, signature, buildSignMessage);
    }
    /**
     * 验证签名
     * @param headers     http 请求头
     * @param body        应答主体
     * @param publicKey   平台公钥
     */
    static verifySign(headers, body, publicKey) {
        let timestamp = headers['wechatpay-timestamp'];
        let nonce = headers['wechatpay-nonce'];
        let signature = headers['wechatpay-signature'];
        let buildSignMessage = this.buildRepSignMessage(timestamp, nonce, body);
        return kits_1.Kits.sha256WithRsaVerify(publicKey, signature, buildSignMessage);
    }
    /**
     * v3 创建签名
     *
     * @param {Array<string>} data  需要参与签名的参数
     * @param {Buffer} key          key.pem 证书
     * @returns {string}            返回签名结果
     */
    static createSign(data, key) {
        return this.createSignByStr(this.buildSignMessage(data), key);
    }
    /**
     * v3 创建签名
     * @param {string} data   需要参与签名的参数
     * @param {Buffer} key    key.pem 证书
     * @returns {string}      返回签名结果
     */
    static createSignByStr(data, key) {
        if (!data) {
            throw new Error('参与签名的参数不能为空,请检查');
        }
        return this.sha256WithRsa(key, data);
    }
    /**
     * 证书和回调报文解密
     * @param key             apiKey3
     * @param nonce           加密使用的随机串初始化向量
     * @param associatedData  附加数据包
     * @param ciphertext      密文
     */
    static aes256gcmDecrypt(key, nonce, associatedData, ciphertext) {
        return kits_1.Kits.aes256gcmDecrypt(key, nonce, associatedData, ciphertext);
    }
    /**
     * SHA256 with RSA 加密生成签名
     * @param key key.pem 证书 key
     * @param data 待签名串
     */
    static sha256WithRsa(key, data) {
        return kits_1.Kits.sha256WithRsa(data, key);
    }
    /**
     * 构建请求签名参数
     * @param method {RequestMethod} Http 请求方式
     * @param url 请求接口 /v3/certificates
     * @param timestamp 获取发起请求时的系统当前时间戳
     * @param nonceStr 随机字符串
     * @param body 请求报文主体
     */
    static buildReqSignMessage(method, url, timestamp, nonceStr, body) {
        return this.buildSignMessage([method, url, timestamp, nonceStr, body]);
    }
    /**
     * 构建应答签名参数
     * @param timestamp 应答时间戳
     * @param nonceStr 应答随机串
     * @param body 应答报文主体
     */
    static buildRepSignMessage(timestamp, nonceStr, body) {
        return this.buildSignMessage([timestamp, nonceStr, body]);
    }
    /**
     * 构建签名参数
     * @param {Array<string>} data 待构建签名的参数
     * @returns {string}           返回待签名字符串
     */
    static buildSignMessage(data) {
        if (!data || data.length <= 0) {
            return null;
        }
        let sign = '';
        data.forEach(item => {
            sign = sign.concat(item).concat('\n');
        });
        return sign;
    }
    /**
     * 拼接参数
     * @param map     待拼接的 Map 数据
     * @param connStr 连接符
     * @param encode  是否 urlencode
     * @param quotes  是否 ""
     */
    static createLinkString(map, connStr, encode, quotes) {
        // 排序
        let arrayObj = Array.from(map);
        arrayObj.sort((a, b) => {
            return a[0].localeCompare(b[0]);
        });
        let content = '';
        for (let i = 0; i < arrayObj.length; i++) {
            let key = arrayObj[i][0];
            let value = arrayObj[i][1];
            // 拼接时，不包括最后一个&字符
            if (i == arrayObj.length - 1) {
                if (quotes) {
                    content = content
                        .concat(key)
                        .concat('=')
                        .concat('"')
                        .concat(encode ? urlencode.encode(value) : value)
                        .concat('"');
                }
                else {
                    content = content
                        .concat(key)
                        .concat('=')
                        .concat(encode ? urlencode.encode(value) : value);
                }
            }
            else {
                if (quotes) {
                    content = content
                        .concat(key)
                        .concat('=')
                        .concat('"')
                        .concat(encode ? urlencode.encode(value) : value)
                        .concat('"')
                        .concat(connStr);
                }
                else {
                    content = content
                        .concat(key)
                        .concat('=')
                        .concat(encode ? urlencode.encode(value) : value)
                        .concat(connStr);
                }
            }
        }
        return content;
    }
    /**
     * 获取授权认证信息
     *
     * @param mchId     商户号
     * @param serialNo  商户API证书序列号
     * @param nonceStr  请求随机串
     * @param timestamp 时间戳
     * @param signature 签名值
     * @param authType  认证类型，目前为WECHATPAY2-SHA256-RSA2048
     */
    static getAuthorization(mchId, serialNo, nonceStr, timestamp, signature, authType) {
        let map = new Map();
        map.set('mchid', mchId);
        map.set('serial_no', serialNo);
        map.set('nonce_str', nonceStr);
        map.set('timestamp', timestamp);
        map.set('signature', signature);
        return authType.concat(' ').concat(this.createLinkString(map, ',', false, true));
    }
    /**
     * 构建 v3 接口所需的 Authorization
     *
     * @param method    {RequestMethod} 请求方法
     * @param urlSuffix 可通过 WxApiType 来获取，URL挂载参数需要自行拼接
     * @param mchId     商户Id
     * @param serialNo  商户 API 证书序列号
     * @param key       key.pem 证书
     * @param body      接口请求参数
     */
    static buildAuthorization(method, urlSuffix, mchId, serialNo, key, body) {
        return __awaiter(this, void 0, void 0, function* () {
            let timestamp = parseInt((Date.now() / 1000).toString()).toString();
            let authType = 'WECHATPAY2-SHA256-RSA2048';
            let nonceStr = kits_1.Kits.generateStr();
            // 构建签名参数
            let buildSignMessage = this.buildReqSignMessage(method, urlSuffix, timestamp, nonceStr, body);
            // 生成签名
            let signature = this.createSignByStr(buildSignMessage, key);
            // 根据平台规则生成请求头 authorization
            return this.getAuthorization(mchId, serialNo, nonceStr, timestamp, signature, authType);
        });
    }
    /**
     * 微信支付 Api-v3 get 请求
     * @param urlPrefix     请求接口前缀，可通过 WxDmainType 来获取
     * @param urlSuffix     请求接口后缀，可通过 WxApiType 来获取
     * @param mchId         商户号
     * @param serialNo      证书序列号
     * @param key           key.pem 证书
     * @param params        请求参数
     * @param platSerialNo  微信平台序列号
     */
    static exeGet(urlPrefix, urlSuffix, mchId, serialNo, key, params, platSerialNo) {
        return __awaiter(this, void 0, void 0, function* () {
            if (params && params.size > 0) {
                urlSuffix = urlSuffix.concat('?').concat(this.createLinkString(params, '&', true, false));
            }
            let authorization = yield this.buildAuthorization(RequestMethod_1.RequestMethod.GET, urlSuffix, mchId, serialNo, key, '');
            return yield this.get(urlPrefix.concat(urlSuffix), authorization, platSerialNo || serialNo);
        });
    }
    /**
     * 微信支付 Api-v3 post 请求
     * @param urlPrefix     请求接口前缀，可通过 WxDmainType 来获取
     * @param urlSuffix     请求接口后缀，可通过 WxApiType 来获取
     * @param mchId         商户号
     * @param serialNo      证书序列号
     * @param key           key.pem 证书
     * @param data          接口请求参数
     * @param platSerialNo  微信平台序列号
     */
    static exePost(urlPrefix, urlSuffix, mchId, serialNo, key, data, platSerialNo) {
        return __awaiter(this, void 0, void 0, function* () {
            let authorization = yield this.buildAuthorization(RequestMethod_1.RequestMethod.POST, urlSuffix, mchId, serialNo, key, data);
            return yield this.post(urlPrefix.concat(urlSuffix), data, authorization, platSerialNo || serialNo);
        });
    }
    /**
     * 微信支付 Api-v3 put 请求
     * @param urlPrefix     请求接口前缀，可通过 WxDmainType 来获取
     * @param urlSuffix     请求接口后缀，可通过 WxApiType 来获取
     * @param mchId         商户号
     * @param serialNo      证书序列号
     * @param key           key.pem 证书
     * @param data          接口请求参数
     * @param platSerialNo  微信平台序列号
     */
    static exePut(urlPrefix, urlSuffix, mchId, serialNo, key, data, platSerialNo) {
        return __awaiter(this, void 0, void 0, function* () {
            let authorization = yield this.buildAuthorization(RequestMethod_1.RequestMethod.PUT, urlSuffix, mchId, serialNo, key, data);
            return yield this.put(urlPrefix.concat(urlSuffix), data, authorization, platSerialNo || serialNo);
        });
    }
    /**
     * 微信支付 Api-v3 delete 请求
     * @param urlPrefix     请求接口前缀，可通过 WxDmainType 来获取
     * @param urlSuffix     请求接口后缀，可通过 WxApiType 来获取
     * @param mchId         商户号
     * @param serialNo      证书序列号
     * @param key           key.pem 证书
     * @param platSerialNo  微信平台序列号
     */
    static exeDelete(urlPrefix, urlSuffix, mchId, serialNo, key, platSerialNo) {
        return __awaiter(this, void 0, void 0, function* () {
            let authorization = yield this.buildAuthorization(RequestMethod_1.RequestMethod.DELETE, urlSuffix, mchId, serialNo, key, '');
            return yield this.delete(urlPrefix.concat(urlSuffix), authorization, platSerialNo || serialNo);
        });
    }
    /**
     * 微信支付 Api-v3 upload 请求
     * @param urlPrefix     请求接口前缀，可通过 WxDmainType 来获取
     * @param urlSuffix     请求接口后缀，可通过 WxApiType 来获取
     * @param mchId         商户号
     * @param serialNo      证书序列号
     * @param key           key.pem 证书
     * @param filePath      需要上传的文件路径
     * @param data          请求参数
     * @param platSerialNo  微信平台序列号
     */
    static exeUpload(urlPrefix, urlSuffix, mchId, serialNo, key, filePath, data, platSerialNo) {
        return __awaiter(this, void 0, void 0, function* () {
            let authorization = yield this.buildAuthorization(RequestMethod_1.RequestMethod.UPLOAD, urlSuffix, mchId, serialNo, key, data);
            return yield this.upload(urlPrefix.concat(urlSuffix), filePath, data, authorization, platSerialNo || serialNo);
        });
    }
    /**
     * get 方法
     * @param url           请求 url
     * @param authorization 授权信息
     * @param serialNumber  证书序列号
     */
    static get(url, authorization, serialNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield kits_1.HttpKit.getHttpDelegate.httpGetToResponse(url, {
                headers: this.getHeaders(authorization, serialNumber)
            });
        });
    }
    /**
     * post 方法
     * @param url           请求 url
     * @param authorization 授权信息
     * @param serialNumber  证书序列号
     */
    static post(url, data, authorization, serialNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield kits_1.HttpKit.getHttpDelegate.httpPostToResponse(url, data, {
                headers: this.getHeaders(authorization, serialNumber)
            });
        });
    }
    /**
     * put 方法
     * @param url           请求 url
     * @param authorization 授权信息
     * @param serialNumber  证书序列号
     */
    static put(url, data, authorization, serialNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield kits_1.HttpKit.getHttpDelegate.httpPutToResponse(url, data, {
                headers: this.getHeaders(authorization, serialNumber)
            });
        });
    }
    /**
     * delete 方法
     * @param url           请求 url
     * @param authorization 授权信息
     * @param serialNumber  证书序列号
     */
    static delete(url, authorization, serialNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield kits_1.HttpKit.getHttpDelegate.httpDeleteToResponse(url, {
                headers: this.getHeaders(authorization, serialNumber)
            });
        });
    }
    /**
     * upload 方法
     * @param url           请求 url
     * @param filePath      文件路径
     * @param data          请求数据
     * @param authorization 授权信息
     * @param serialNumber  证书序列号
     */
    static upload(url, filePath, data, authorization, serialNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            let headers = this.getHeaders(authorization, serialNumber);
            headers['Content-type'] = 'multipart/form-data';
            return yield kits_1.HttpKit.getHttpDelegate.uploadToResponse(url, filePath, data, {
                headers
            });
        });
    }
    /**
     * 获取请求头
     * @param authorization 授权信息
     * @param serialNumber  证书序列号
     */
    static getHeaders(authorization, serialNumber) {
        let userAgent = 'WeChatPay-TNWX-HttpClient/%s (%s) nodejs/%s';
        userAgent = util.format(userAgent, '2.4.0', os
            .platform()
            .concat('/')
            .concat(os.release()), process.version);
        return {
            Authorization: authorization,
            Accept: 'application/json',
            'Content-type': 'application/json',
            'Wechatpay-Serial': serialNumber,
            'User-Agent': userAgent
        };
    }
    /**
     * 微信支付 Api-v3
     *
     * @param {RequestMethod} requestMethod 请求方式
     * @param {string} urlPrefix 请求接口前缀，可通过 WxDmainType 来获取
     * @param {string} urlSuffix 请求接口后缀，可通过 WxApiType 来获取
     * @param {string} mchId 商户号
     * @param {string} serialNo 证书序列号
     * @param {Buffer} key  key.pem 证书
     * @param {string} [data] 请求参数
     * @param {Map<string, string>} [params] get 请求参数
     * @param {string} [platSerialNo] 微信平台序列号
     * @param {string} [filePath] 需要上传的文件路径
     */
    static v3(requestMethod, urlPrefix, urlSuffix, mchId, serialNo, key, data, params, platSerialNo, filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (requestMethod) {
                case RequestMethod_1.RequestMethod.GET:
                    return this.exeGet(urlPrefix, urlSuffix, mchId, serialNo, key, params, platSerialNo);
                case RequestMethod_1.RequestMethod.POST:
                    return this.exePost(urlPrefix, urlSuffix, mchId, serialNo, key, data, platSerialNo);
                case RequestMethod_1.RequestMethod.DELETE:
                    return this.exeDelete(urlPrefix, urlSuffix, mchId, serialNo, key, platSerialNo);
                case RequestMethod_1.RequestMethod.UPLOAD:
                    return this.exeUpload(urlPrefix, urlSuffix, mchId, serialNo, key, filePath, data, platSerialNo);
                case RequestMethod_1.RequestMethod.PUT:
                    return this.exePut(urlPrefix, urlSuffix, mchId, serialNo, key, data, platSerialNo);
                default:
                    break;
            }
        });
    }
}
exports.PayKit = PayKit;
//# sourceMappingURL=PayKit.js.map